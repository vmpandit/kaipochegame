<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kai Po Che: Uttarayan Master</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Poppins', sans-serif;
            touch-action: none; /* Critical for mobile games */
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 2px 2px 0px #000;
            font-weight: 900;
            font-size: 1.2rem;
            z-index: 10;
        }

        /* Mobile Controls Hints */
        #mobile-hint-overlay {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 50%;
            display: none; /* Toggled by JS */
            pointer-events: none;
        }
        
        .zone-hint {
            position: absolute;
            bottom: 20px;
            width: 40%;
            height: 100px;
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.8rem;
            text-align: center;
        }
        .left-zone { left: 20px; }
        .right-zone { right: 20px; background: rgba(255,0,0,0.1); }

        /* Screens (Start, Level, Game Over) */
        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            backdrop-filter: blur(4px);
        }

        .panel {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 85%;
            border: 4px solid #FFD700;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        h1 { color: #e63946; margin: 0; font-size: 2.5rem; line-height: 1; text-transform: uppercase; }
        h2 { color: #1d3557; margin-bottom: 5px; }
        p { color: #555; font-size: 0.95rem; margin-bottom: 20px; }
        
        .stat-box {
            background: #f0f0f0;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
            font-size: 0.9rem;
        }

        button {
            background: linear-gradient(to bottom, #ff6b6b, #ee5253);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(238, 82, 83, 0.4);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        .hidden { display: none !important; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div>
                <span id="scoreDisplay">0</span> PTS<br>
                <div id="starsDisplay" style="color: #FFD700; font-size: 1.5rem;">‚òÜ‚òÜ‚òÜ</div>
            </div>
            <div style="text-align: right;">
                <span id="levelDisplay">LVL 1</span><br>
                <span id="kiteDisplay" style="color:#ff6b6b">ü™Å x3</span><br>
                <span id="stringDisplay" style="color:#48dbfb; font-size: 0.9rem;">üßµ 100%</span>
            </div>
        </div>

        <div id="mobile-hint-overlay">
            <div class="zone-hint left-zone">DRAG HERE<br>TO STEER</div>
            <div class="zone-hint right-zone">HOLD HERE<br>TO PULL (ATTACK)</div>
        </div>
    </div>

    <div id="screens">
        <div id="start-screen" class="panel">
            <h1>Kai Po Che!</h1>
            <p>Uttarayan Kite Festival Simulator</p>
            
            <div class="stat-box">
                <b>Controls:</b><br>
                üñ±Ô∏è <b>Mouse:</b> Move to steer, Click/Hold to PULL.<br>
                üì± <b>Touch:</b> Left side steers, Right side PULLS.
            </div>

            <p style="font-size:0.8rem; color:#888;">Rule: Pull string to attack. Release to float.</p>
            <button onclick="startGame()">Start Festival</button>
        </div>

        <div id="level-screen" class="panel hidden">
            <h2 id="level-title">Level 1</h2>
            <p id="level-desc">Conditions: Calm Winds</p>
            <button onclick="startLevel()">Fly!</button>
        </div>

        <div id="gameover-screen" class="panel hidden">
            <h1 id="go-title">Game Over</h1>
            <p id="go-reason">Out of kites!</p>
            <h2 id="go-score">0</h2>
            <div id="go-stars" style="font-size: 2.5rem; color: gold; margin-bottom: 20px;"></div>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

<script>
/**
 * KAI PO CHE - FIXED & DEBUGGED
 */

// --- CONFIG & STATE ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

let gameState = {
    screen: 'start',
    level: 1,
    score: 0,
    totalStars: 0,
    lives: 3,
    stringLeft: 100,
    maxLevels: 10,
    isMobile: false,
    invulnerable: 0 // Timer for respawn safety
};

let input = {
    pulling: false,
    targetX: window.innerWidth / 2, // Where we want to steer
    targetY: window.innerHeight / 2
};

let physics = {
    gravity: 0.1,
    friction: 0.96,
    pullForce: 0.85,
    lift: -0.08, // Increased lift for easier "Dheel"
    wind: { x: 0.5, y: 0 }
};

// Game Objects
let player;
let enemies = [];
let particles = [];
let buildings = [];

// --- AUDIO SYSTEM (Fixed for Browser Policy) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundEnabled = false;

function initAudio() {
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    soundEnabled = true;
}

function playTone(type) {
    if (!soundEnabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    
    if (type === 'cut') {
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'die') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    }
}

// --- SETUP & UTILS ---

function resize() {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
    generateCity();
    
    // Check mobile
    gameState.isMobile = ('ontouchstart' in window) || (window.innerWidth < 800);
    if(gameState.isMobile) {
        document.getElementById('mobile-hint-overlay').style.display = 'block';
    }
}
window.addEventListener('resize', resize);

function generateCity() {
    buildings = [];
    let x = 0;
    while(x < CANVAS.width) {
        let w = 40 + Math.random() * 80;
        let h = 80 + Math.random() * 150;
        let c = `hsl(${Math.random()*40+10}, 40%, ${60+Math.random()*20}%)`;
        buildings.push({x: x, y: CANVAS.height - h, w: w, h: h, c: c});
        x += w - 5;
    }
}

// --- CLASSES ---

class Kite {
    constructor(isPlayer, x, y, color) {
        this.isPlayer = isPlayer;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.color = color;
        this.cut = false;
        this.active = true;
        this.tail = Array(10).fill({x:x, y:y});
        this.size = 15;
    }

    update() {
        if (!this.active) return;

        // Cut Physics
        if (this.cut) {
            this.vx += physics.wind.x * 0.1;
            this.vy += physics.gravity;
            this.angle += 0.15;
            this.x += this.vx;
            this.y += this.vy;
            if(this.y > CANVAS.height + 100) this.active = false;
            this.updateTail();
            return;
        }

        let isPulling = false;
        let steer = 0;

        if (this.isPlayer) {
            // String check
            if (gameState.stringLeft <= 0) {
                input.pulling = false; // Forced Dheel
            }

            isPulling = input.pulling;
            
            // Steering Logic
            let dx = input.targetX - this.x;
            // Dampen steering based on distance to prevent jitter
            steer = dx * 0.003; 

            // Consume String
            if(isPulling && gameState.stringLeft > 0) {
                gameState.stringLeft -= 0.03;
                if(gameState.stringLeft < 0) gameState.stringLeft = 0;
            }
        } else {
            // AI Logic
            if(player && !player.cut) {
                let dx = player.x - this.x;
                steer = dx * (0.001 * (1 + gameState.level * 0.2)); // AI gets smarter
                
                // Attack logic
                let dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < 150 && Math.random() < 0.05) isPulling = true;
                if (this.y > CANVAS.height * 0.6) isPulling = true; // Recover altitude
            }
            // Keep AI in bounds
            if(this.x < 50) steer += 0.05;
            if(this.x > CANVAS.width - 50) steer -= 0.05;
        }

        // Apply Physics
        let forceX = physics.wind.x * 0.3;
        let forceY = physics.wind.y * 0.3;

        if (isPulling) {
            // High Tension: Move forward, turn fast
            forceX += Math.cos(this.angle) * physics.pullForce * 1.5;
            forceY += Math.sin(this.angle) * physics.pullForce * 1.5;
            this.angle += steer * 2;
        } else {
            // Low Tension: Drift, Lift, Right itself
            forceX += physics.wind.x;
            forceY += physics.gravity + physics.lift;
            // Self-righting mechanism
            let targetAngle = -Math.PI/2 + (physics.wind.x * 0.5);
            this.angle += (targetAngle - this.angle) * 0.08;
            this.angle += steer * 0.5;
        }

        this.vx += forceX;
        this.vy += forceY;
        this.vx *= physics.friction;
        this.vy *= physics.friction;

        this.x += this.vx;
        this.y += this.vy;

        // Player Floor Collision
        if (this.isPlayer && this.y > CANVAS.height - 80) {
            this.y = CANVAS.height - 80;
            this.vy = -1; // Bounce
        }

        this.updateTail();
    }

    updateTail() {
        let prev = {x: this.x, y: this.y};
        this.tail = this.tail.map((node, i) => {
            let dx = prev.x - node.x;
            let dy = prev.y - node.y;
            let dist = Math.hypot(dx, dy);
            let angle = Math.atan2(dy, dx);
            let slack = 8;
            
            let nx = node.x;
            let ny = node.y;

            if (dist > slack) {
                nx = prev.x - Math.cos(angle) * slack;
                ny = prev.y - Math.sin(angle) * slack;
            }
            // Waving effect
            nx += Math.sin(Date.now()/150 + i) * 1.5;
            
            prev = {x: nx, y: ny};
            return {x: nx, y: ny};
        });
    }

    draw() {
        if (!this.active) return;
        
        // Blink if invulnerable
        if (this.isPlayer && gameState.invulnerable > 0) {
            if (Math.floor(Date.now() / 100) % 2 === 0) return;
        }

        // String
        if (!this.cut) {
            CTX.beginPath();
            CTX.moveTo(this.x, this.y);
            let endX = this.isPlayer ? CANVAS.width/2 : this.x + (physics.wind.x * 200);
            let endY = CANVAS.height;
            let tension = (this.isPlayer && input.pulling) ? 0 : 100;
            CTX.quadraticCurveTo((this.x+endX)/2, (this.y+endY)/2 + tension, endX, endY);
            CTX.strokeStyle = this.isPlayer ? 'white' : 'red';
            CTX.lineWidth = this.isPlayer ? 1.5 : 0.5;
            CTX.stroke();
        }

        // Tail
        CTX.beginPath();
        CTX.moveTo(this.x, this.y);
        this.tail.forEach(p => CTX.lineTo(p.x, p.y));
        CTX.strokeStyle = this.color;
        CTX.lineWidth = 2;
        CTX.stroke();

        // Body
        CTX.save();
        CTX.translate(this.x, this.y);
        CTX.rotate(this.angle + Math.PI/2);
        
        CTX.fillStyle = this.color;
        CTX.beginPath();
        CTX.moveTo(0, -this.size);
        CTX.lineTo(this.size/1.2, 0);
        CTX.lineTo(0, this.size);
        CTX.lineTo(-this.size/1.2, 0);
        CTX.fill();
        
        // Highlight
        CTX.fillStyle = 'rgba(255,255,255,0.2)';
        CTX.beginPath();
        CTX.moveTo(0, -this.size);
        CTX.lineTo(0, this.size);
        CTX.lineTo(this.size/1.2, 0);
        CTX.fill();
        
        CTX.restore();
    }
}

// --- CORE LOOPS ---

function startGame() {
    initAudio();
    gameState.score = 0;
    gameState.totalStars = 0;
    gameState.lives = 3;
    gameState.level = 1;
    gameState.stringLeft = 100;
    showScreen('level-screen');
    setupLevel();
}

function resetGame() {
    startGame();
}

function setupLevel() {
    // Config based on level
    let lvl = gameState.level;
    document.getElementById('level-title').innerText = "Level " + lvl;
    
    // Wind Difficulty
    if (lvl < 4) {
        physics.wind = {x: 0.5 + (lvl * 0.1), y: 0};
        document.getElementById('level-desc').innerText = "Wind: Moderate Breeze";
    } else {
        physics.wind = {x: 1.0 + Math.random(), y: (Math.random()-0.5) * 0.5};
        document.getElementById('level-desc').innerText = "Wind: High & Unpredictable!";
    }
}

function startLevel() {
    showScreen('playing');
    spawnPlayer();
    
    enemies = [];
    let count = 1 + Math.ceil(gameState.level / 2);
    for(let i=0; i<count; i++) spawnEnemy();

    gameLoop();
}

function spawnPlayer() {
    player = new Kite(true, CANVAS.width/2, CANVAS.height - 200, '#FFD700');
    gameState.invulnerable = 120; // 2 seconds at 60fps
    input.targetX = CANVAS.width/2; // Reset steering
}

function spawnEnemy() {
    let x = Math.random() * CANVAS.width;
    let y = Math.random() * (CANVAS.height / 2) + 50;
    let colors = ['#ff4757', '#2ed573', '#1e90ff', '#ffa502'];
    let c = colors[Math.floor(Math.random() * colors.length)];
    enemies.push(new Kite(false, x, y, c));
}

function updatePhysics() {
    if (gameState.invulnerable > 0) gameState.invulnerable--;

    if (player) player.update();
    
    enemies.forEach(e => e.update());

    // Collision Detection
    if (player && !player.cut && gameState.invulnerable === 0) {
        enemies.forEach(e => {
            if (e.cut) return;
            
            let dist = Math.hypot(player.x - e.x, player.y - e.y);
            
            // "String" intersection range
            if (dist < 30) {
                resolveCombat(player, e);
            }
        });
    }
}

function resolveCombat(k1, k2) {
    // k1 is player, k2 is enemy
    // Win Logic: Pulling beats Releasing. Higher Altitude (Attacking from above) is advantage.
    
    let k1Score = (input.pulling ? 2 : 0) + (k1.y < k2.y ? 1 : 0);
    let k2Score = (k2.y < k1.y ? 1 : 0) + 1; // AI Base skill

    // Random Variance based on level
    let luck = Math.random() * 2;
    
    // Level scaling: Enemies get harder
    if (gameState.level > 5) k2Score += 1;

    if (k1Score + luck > k2Score) {
        // Player Wins
        cutKite(k2);
        gameState.score += 100 * gameState.level;
        playTone('cut');
        createExplosion(k2.x, k2.y, k2.color);
    } else {
        // Player Loses
        cutKite(k1);
        playTone('die');
        createExplosion(k1.x, k1.y, k1.color);
        setTimeout(handleDeath, 1000);
    }
}

function cutKite(k) {
    k.cut = true;
    k.vx = physics.wind.x * 5;
    k.vy = -2;
}

function handleDeath() {
    gameState.lives--;
    updateHUD();
    
    if (gameState.lives <= 0) {
        // Game Over
        document.getElementById('go-reason').innerText = "All kites cut!";
        showGameOver();
    } else {
        spawnPlayer(); // Respawn
    }
}

function checkWinCondition() {
    let activeEnemies = enemies.filter(e => !e.cut).length;
    if (activeEnemies === 0 && enemies.length > 0) {
        // Level Won
        gameState.level++;
        if (gameState.level > gameState.maxLevels) {
            document.getElementById('go-reason').innerText = "Festival Champion!";
            showGameOver();
        } else {
            enemies = []; // Clear array
            showScreen('level-screen');
            setupLevel();
        }
    }
}

function showGameOver() {
    gameState.screen = 'gameover';
    document.getElementById('go-score').innerText = gameState.score;
    let stars = "";
    let sCount = Math.min(3, Math.floor(gameState.score / 1000) + 1);
    for(let i=0; i<3; i++) stars += (i<sCount ? "‚òÖ" : "‚òÜ");
    document.getElementById('go-stars').innerText = stars;
    showScreen('gameover-screen');
}

// --- RENDERING ---

function draw() {
    CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);

    // Sky
    let grd = CTX.createLinearGradient(0, 0, 0, CANVAS.height);
    grd.addColorStop(0, "#87CEEB");
    grd.addColorStop(1, "#E0F7FA");
    CTX.fillStyle = grd;
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    // City
    buildings.forEach(b => {
        CTX.fillStyle = b.c;
        CTX.fillRect(b.x, b.y, b.w, b.h);
        CTX.fillStyle = "rgba(0,0,0,0.1)"; // Windows
        for(let wy=b.y+10; wy<CANVAS.height; wy+=20)
            for(let wx=b.x+5; wx<b.x+b.w-5; wx+=12)
                CTX.fillRect(wx, wy, 6, 12);
    });

    if (player) player.draw();
    enemies.forEach(e => e.draw());
    
    drawParticles();
}

function createExplosion(x, y, color) {
    for(let i=0; i<15; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
            life: 1, color: color
        });
    }
}

function drawParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        CTX.fillStyle = p.color;
        CTX.globalAlpha = p.life;
        CTX.beginPath(); CTX.arc(p.x, p.y, 3, 0, Math.PI*2); CTX.fill();
        CTX.globalAlpha = 1;
        if(p.life <= 0) particles.splice(i,1);
    }
}

function gameLoop() {
    if (gameState.screen !== 'playing') return;
    
    updatePhysics();
    checkWinCondition();
    draw();
    updateHUD();
    requestAnimationFrame(gameLoop);
}

function updateHUD() {
    document.getElementById('scoreDisplay').innerText = gameState.score;
    document.getElementById('levelDisplay').innerText = "LVL " + gameState.level;
    document.getElementById('kiteDisplay').innerText = "ü™Å x" + gameState.lives;
    document.getElementById('stringDisplay').innerText = "üßµ " + Math.floor(gameState.stringLeft) + "%";
}

// --- INPUTS (Unified Mouse/Touch) ---

function handleInputStart(x, y) {
    if (gameState.isMobile) {
        if (x < window.innerWidth / 2) {
            // Steering Zone
            input.targetX = (x / (window.innerWidth/2)) * window.innerWidth;
        } else {
            // Pull Zone
            input.pulling = true;
        }
    } else {
        input.pulling = true;
    }
}

function handleInputEnd() {
    input.pulling = false;
}

function handleInputMove(x, y) {
    if (gameState.isMobile) {
        if (x < window.innerWidth / 2) {
             // Map left-half touch to full-width steering
             input.targetX = (x / (window.innerWidth/2)) * window.innerWidth;
        }
    } else {
        input.targetX = x;
        input.targetY = y;
    }
}

// Mouse Listeners
window.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
window.addEventListener('mouseup', handleInputEnd);
window.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));

// Touch Listeners
window.addEventListener('touchstart', e => {
    for(let i=0; i<e.touches.length; i++) {
        handleInputStart(e.touches[i].clientX, e.touches[i].clientY);
    }
}, {passive: false});

window.addEventListener('touchend', e => {
    // If no touches remain on right side, stop pulling
    let rightSideTouch = false;
    for(let i=0; i<e.touches.length; i++) {
        if (e.touches[i].clientX > window.innerWidth/2) rightSideTouch = true;
    }
    if (!rightSideTouch) input.pulling = false;
});

window.addEventListener('touchmove', e => {
    e.preventDefault(); // Prevent scrolling
    for(let i=0; i<e.touches.length; i++) {
        handleInputMove(e.touches[i].clientX, e.touches[i].clientY);
    }
}, {passive: false});

// --- UI HELPER ---
function showScreen(id) {
    document.querySelectorAll('.panel').forEach(p => p.classList.add('hidden'));
    document.getElementById(id).classList.remove('hidden');
    document.getElementById('screens').style.display = (id === 'playing') ? 'none' : 'flex';
    gameState.screen = id;
}

// Boot
resize();
generateCity();

</script>
</body>
</html>